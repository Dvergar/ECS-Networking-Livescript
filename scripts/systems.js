// Generated by LiveScript 1.2.0
(function(){
  'use strict';
  var PhaserDrawableSystem, PhaserInputSystem, ControllerSystem, CollisionSystem, MovementSystem, TargetSystem, PhaserFollowMouseSystem, ShipCollisionSystem, out$ = typeof exports != 'undefined' && exports || this;
  PhaserDrawableSystem = (function(superclass){
    var prototype = extend$((import$(PhaserDrawableSystem, superclass).displayName = 'PhaserDrawableSystem', PhaserDrawableSystem), superclass).prototype, constructor = PhaserDrawableSystem;
    prototype.drawables = {};
    function PhaserDrawableSystem(){
      this.need([CDrawable, CPosition]);
    }
    prototype.onEntityAdded = function(entity){
      var drawable, pos, x$, graphics, sprite, img;
      console.log("DRAWABLE ENTITY ADDED");
      drawable = entity.get(CDrawable);
      pos = entity.get(CPosition);
      if (drawable.type === CDrawable.Type.RECTANGLE) {
        x$ = graphics = game.add.graphics(0, 0);
        x$.beginFill(drawable.color);
        x$.drawRect(0, 0, drawable.width, drawable.height);
        this.drawables[entity.id] = graphics;
      }
      if (drawable.type === CDrawable.Type.IMAGE) {
        sprite = game.add.sprite(0, 0, drawable.image_name);
        this.drawables[entity.id] = sprite;
        sprite.anchor.setTo(drawable.anchorx, drawable.anchory);
        img = game.cache.getImage(drawable.image_name);
        drawable.width = img.width;
        drawable.height = img.height;
        return console.log('width_' + drawable.width);
      }
    };
    prototype.loop = function(){
      var id, ref$, entity, pos, draw, x$, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        pos = entity.get(CPosition);
        draw = entity.get(CDrawable);
        x$ = this.drawables[id];
        x$.x = pos.x;
        x$.y = pos.y;
        x$.angle = pos.rotation;
        results$.push(x$);
      }
      return results$;
    };
    return PhaserDrawableSystem;
  }(System));
  PhaserInputSystem = (function(superclass){
    var prototype = extend$((import$(PhaserInputSystem, superclass).displayName = 'PhaserInputSystem', PhaserInputSystem), superclass).prototype, constructor = PhaserInputSystem;
    function PhaserInputSystem(){
      this.need([CPosition, CInput]);
      this.keyUp = game.input.keyboard.addKey(Phaser.Keyboard.UP);
      this.keyDown = game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
      this.keyLeft = game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
      this.keyRight = game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
    }
    prototype.loop = function(){
      var id, ref$, entity, x$, input, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        x$ = input = entity.get(CInput);
        x$.keyUp = this.keyUp.isDown;
        x$.keyDown = this.keyDown.isDown;
        x$.keyLeft = this.keyLeft.isDown;
        x$.keyRight = this.keyRight.isDown;
        results$.push(x$);
      }
      return results$;
    };
    return PhaserInputSystem;
  }(System));
  ControllerSystem = (function(superclass){
    var prototype = extend$((import$(ControllerSystem, superclass).displayName = 'ControllerSystem', ControllerSystem), superclass).prototype, constructor = ControllerSystem;
    function ControllerSystem(){
      this.need([CPosition, CInput, CSpeed]);
    }
    prototype.loop = function(){
      var id, ref$, entity, input, pos, speed, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        input = entity.get(CInput);
        pos = entity.get(CPosition);
        speed = entity.get(CSpeed);
        if (input.keyUp) {
          pos.dy -= speed.value;
        }
        if (input.keyDown) {
          pos.dy += speed.value;
        }
        if (input.keyLeft) {
          pos.dx -= speed.value;
        }
        if (input.keyRight) {
          results$.push(pos.dx += speed.value);
        }
      }
      return results$;
    };
    return ControllerSystem;
  }(System));
  CollisionSystem = (function(superclass){
    var prototype = extend$((import$(CollisionSystem, superclass).displayName = 'CollisionSystem', CollisionSystem), superclass).prototype, constructor = CollisionSystem;
    function CollisionSystem(){
      this.need([CCollidable, CPosition, CDrawable]);
    }
    prototype.collides_by_axis = function(o1pos, o1size, o2pos, o2size){
      return o1pos + o1size > o2pos && o2pos + o2size > o1pos;
    };
    prototype.collides = function(o1, o2){
      return this.collides_by_axis(o1.x, o1.width, o2.x, o2.width) && this.collides_by_axis(o1.y, o1.height, o2.y, o2.height);
    };
    prototype.get_overlap = function(o1previous_pos, o1pos, o1size, o2pos, o2size){
      if (o1previous_pos > o2pos) {
        return -((o2pos + o2size) - o1pos);
      } else {
        return (o1pos + o1size) - o2pos;
      }
    };
    prototype.resolve_objects = function(o1, o2){
      var axis_x, axis_y, pp_collides_x, pp_collides_y, overlap_x, overlap_y;
      axis_x = false;
      axis_y = false;
      pp_collides_x = this.collides_by_axis(o1.px, o1.x, o1.width, o2.x, o2.width);
      pp_collides_y = this.collides_by_axis(o1.py, o1.y, o1.height, o2.y, o2.height);
      if (pp_collides_x) {
        axis_y = true;
      }
      if (pp_collides_y) {
        axis_x = true;
      }
      overlap_x = this.get_overlap(o1.px, o1.x, o1.width, o2.x, o2.width);
      overlap_y = this.get_overlap(o1.py, o1.y, o1.height, o2.y, o2.height);
      if (o1.immovable !== true) {
        if (Math.abs(overlap_x) < Math.abs(overlap_y)) {
          return o1.x -= overlap_x;
        } else {
          return o1.y -= overlap_y;
        }
      }
    };
    prototype.loop = function(){
      var id, ref$, entity, first_list, second_list, pos, coll, draw, o1, id2, ref1$, other, otherPos, otherColl, otherDraw, o2, i$, len$, obj, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        first_list = [];
        second_list = [];
        pos = entity.get(CPosition);
        coll = entity.get(CCollidable);
        draw = entity.get(CDrawable);
        o1 = {
          x: pos.x + pos.dx - draw.width * draw.anchorx,
          y: pos.y + pos.dy - draw.height * draw.anchory,
          px: pos.x - draw.width * draw.anchorx,
          py: pos.y - draw.height * draw.anchory,
          width: draw.width,
          height: draw.height,
          immovable: coll.immovable
        };
        for (id2 in ref1$ = this.entities) {
          other = ref1$[id2];
          if (other === entity) {
            continue;
          }
          otherPos = other.get(CPosition);
          otherColl = other.get(CCollidable);
          otherDraw = other.get(CDrawable);
          o2 = {
            x: otherPos.x + otherPos.dx - otherDraw.width * otherDraw.anchorx,
            y: otherPos.y + otherPos.dy - otherDraw.height * otherDraw.anchory,
            width: otherDraw.width,
            height: otherDraw.height
          };
          if (!this.collides(o1, o2)) {
            continue;
          }
          if (this.collides_by_axis(o1.px, o1.x, o1.width, o2.x, o2.width) || this.collides_by_axis(o1.py, o1.y, o1.height, o2.y, o2.height)) {
            first_list.push(o2);
          } else {
            second_list.push(o2);
          }
        }
        for (i$ = 0, len$ = first_list.length; i$ < len$; ++i$) {
          obj = first_list[i$];
          this.resolve_objects(o1, obj);
        }
        for (i$ = 0, len$ = second_list.length; i$ < len$; ++i$) {
          obj = second_list[i$];
          this.resolve_objects(o1, obj);
        }
        pos.dx = o1.x - pos.x + draw.width * draw.anchorx;
        results$.push(pos.dy = o1.y - pos.y + draw.height * draw.anchory);
      }
      return results$;
    };
    return CollisionSystem;
  }(System));
  MovementSystem = (function(superclass){
    var prototype = extend$((import$(MovementSystem, superclass).displayName = 'MovementSystem', MovementSystem), superclass).prototype, constructor = MovementSystem;
    function MovementSystem(){
      this.need([CPosition]);
    }
    prototype.loop = function(){
      var id, ref$, entity, pos, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        pos = entity.get(CPosition);
        pos.x += pos.dx;
        pos.y += pos.dy;
        pos.dx = 0;
        results$.push(pos.dy = 0);
      }
      return results$;
    };
    return MovementSystem;
  }(System));
  TargetSystem = (function(superclass){
    var prototype = extend$((import$(TargetSystem, superclass).displayName = 'TargetSystem', TargetSystem), superclass).prototype, constructor = TargetSystem;
    function TargetSystem(){
      this.need([CPosition, CTargetPosition]);
    }
    prototype.onEntityAdded = function(entity){
      var pos, tpos;
      pos = entity.get(CPosition);
      tpos = entity.get(CTargetPosition);
      tpos.startx = pos.x;
      tpos.starty = pos.y;
      return tpos.percent = tpos.step;
    };
    prototype.onEntityRemoved = function(entity){
      return console.log('entity_remove_from_TargetSystem');
    };
    prototype.loop = function(){
      var id, ref$, entity, pos, tpos, newx, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        pos = entity.get(CPosition);
        tpos = entity.get(CTargetPosition);
        newx = tpos.startx + (tpos.x - tpos.startx) * tpos.percent;
        pos.dx = newx - pos.x;
        tpos.percent += tpos.step;
        if (tpos.percent > 1) {
          results$.push(em.removeComponent(entity, CTargetPosition));
        }
      }
      return results$;
    };
    return TargetSystem;
  }(System));
  PhaserFollowMouseSystem = (function(superclass){
    var prototype = extend$((import$(PhaserFollowMouseSystem, superclass).displayName = 'PhaserFollowMouseSystem', PhaserFollowMouseSystem), superclass).prototype, constructor = PhaserFollowMouseSystem;
    prototype.history = {};
    function PhaserFollowMouseSystem(){
      this.need([CPosition, CPhaserFollowMouse, CDrawable]);
    }
    prototype.onEntityAdded = function(entity){
      var pos;
      pos = entity.get(CPosition);
      return this.history[entity.id] = [[pos.x, pos.y]];
    };
    prototype.loop = function(){
      var id, ref$, entity, pos, draw, dx, dy, d, v, x$, results$ = [];
      for (id in ref$ = this.entities) {
        entity = ref$[id];
        pos = entity.get(CPosition);
        draw = entity.get(CDrawable);
        dx = game.input.mousePointer.x - this.history[id][0][0];
        dy = game.input.mousePointer.y - this.history[id][0][1];
        d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        if (d > 0) {
          v = [dx / d, dy / d];
          pos.rotation = Math.atan2(v[1], v[0]) * 180 / Math.PI;
        }
        pos.dx = game.input.mousePointer.x - pos.x;
        pos.dy = game.input.mousePointer.y - pos.y;
        x$ = this.history[id];
        if (d > 5) {
          x$.push([pos.x, pos.y]);
        }
        if (x$.length > 10) {
          x$.shift();
        }
        results$.push(x$);
      }
      return results$;
    };
    return PhaserFollowMouseSystem;
  }(System));
  ShipCollisionSystem = (function(superclass){
    var prototype = extend$((import$(ShipCollisionSystem, superclass).displayName = 'ShipCollisionSystem', ShipCollisionSystem), superclass).prototype, constructor = ShipCollisionSystem;
    function ShipCollisionSystem(){
      this.need([CCollidable, CShip, CDrawable]);
    }
    prototype.collides = function(a, b){
      var apos, bpos, adraw, bdraw;
      apos = a.get(CPosition);
      bpos = b.get(CPosition);
      adraw = a.get(CDrawable);
      bdraw = b.get(CDrawable);
      return !(apos.y + adraw.height < bpos.y || apos.y > bpos.y + bdraw.height || apos.x + adraw.width < bpos.x || apos.x > bpos.x + bdraw.width);
    };
    prototype.loop = function(){
      var id, ref$, ship, lresult$, shipPos, shipDrawable, x$, shipSprite, id2, ref1$, collidable, results$ = [];
      for (id in ref$ = this.entities) {
        ship = ref$[id];
        lresult$ = [];
        shipPos = ship.get(CPosition);
        shipDrawable = ship.get(CDrawable);
        x$ = shipSprite = Moo.phaserDrawableSystem.drawables[ship.id];
        x$.alpha = 1;
        emitter.x = shipSprite.x;
        emitter.y = shipSprite.y;
        emitter.start(true, 500, null, 1);
        for (id2 in ref1$ = Moo.collisionSystem.entities) {
          collidable = ref1$[id2];
          if (ship === collidable) {
            continue;
          }
          if (this.collides(ship, collidable)) {
            lresult$.push(shipSprite.alpha = 0.5);
          }
        }
        results$.push(lresult$);
      }
      return results$;
    };
    return ShipCollisionSystem;
  }(System));
  out$.PhaserDrawableSystem = PhaserDrawableSystem;
  out$.PhaserInputSystem = PhaserInputSystem;
  out$.ControllerSystem = ControllerSystem;
  out$.TargetSystem = TargetSystem;
  out$.PhaserFollowMouseSystem = PhaserFollowMouseSystem;
  out$.CollisionSystem = CollisionSystem;
  out$.ShipCollisionSystem = ShipCollisionSystem;
  out$.MovementSystem = MovementSystem;
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
